{-# LANGUAGE DataKinds, KindSignatures, UndecidableInstances #-}

signature Data.Tensor.Types where

-- this signature roughly corresponds to tf.bitwise and tf.math in the TensorFlow Python API

import Data.Bits 
import Data.Singletons.Prelude.List (Product)
import Data.Vector (Vector)
import GHC.TypeLits
--import GHC.Exts (Constraint)
import Numeric.Dimensions --(KnownDim(..))


-- | Implementation-dependant constraint on the tensor elements.
class Elt e

data T (d :: [Nat]) e

-- may want to use a default instance from the equals op
-- instance (Elt e, Eq e) => Eq (T d e)
instance (KnownDim (Product d), Elt e, Num e) => Num (T d e) 
instance (KnownDim (Product d), Elt e, Fractional e) => Fractional (T d e) 
instance (KnownDim (Product d), Elt e, Floating e) => Floating (T d e) 
instance (KnownDim (Product d), Elt e, Eq e, Bits e, Num e) => Bits (T d e) 

constant
  :: forall d e. Elt e
  => KnownDim (Product d)
  => Vector e
  -> Maybe (T d e)

less
  :: forall d e. Elt e
  => Ord e
  => T d e
  -> T d e
  -> T d Bool

lessEqual
  :: forall d e. Elt e
  => Ord e
  => T d e
  -> T d e
  -> T d Bool

greater
  :: forall d e. Elt e
  => Ord e
  => T d e
  -> T d e
  -> T d Bool

greaterEqual
  :: forall d e. Elt e
  => Ord e
  => T d e
  -> T d e
  -> T d Bool

maximum
  :: forall d e. Elt e
  => Ord e
  => T d e
  -> T d e
  -> T d e

minimum
  :: forall d e. Elt e
  => Ord e
  => T d e
  -> T d e
  -> T d e

{-
vector :: TensorType a => [a] -> Tensor Build a 
zeros :: forall a. (Num a, TensorType a) => Shape -> Tensor Build a


instance Floating e => Floating (T s e)
instance Fractional e => Fractional (T s e)
instance RealFrac e => RealFrac (T s e)
-}
