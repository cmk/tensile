{-# LANGUAGE DataKinds, KindSignatures, UndecidableInstances #-}

signature Data.Tensor.Types where

-- this signature roughly corresponds to tf.bitwise and tf.math in the TensorFlow Python API

import Data.Bits 
import Data.Singletons.Prelude.List (Product)
import Data.Vector (Vector)
import GHC.TypeLits
--import GHC.Exts (Constraint)
import Numeric.Dimensions --(KnownDim(..))


data TVal :: *
instance Eq TVal
instance Num TVal
instance Fractional TVal
instance Floating TVal

data IVal :: *
instance Eq IVal
instance Ord IVal
instance Bits IVal
instance Num IVal

data Tensor (d :: [Nat]) e



-- | A variable tensor. Need ST-like interface w/ ghost type for variables.
--newtype V v (d :: [Nat]) 

instance (KnownDim (Product d), Eq e) => Eq (Tensor d e)
instance (KnownDim (Product d), Eq e, Bits e, Num e) => Bits (Tensor d e) 
instance (KnownDim (Product d), Num e) => Num (Tensor d e) 
instance (KnownDim (Product d), Fractional e) => Fractional (Tensor d e) 
instance (KnownDim (Product d), Floating e) => Floating (Tensor d e)
-- instance (Elt e, Integral e) => Integral (Tensor d e) 
-- instance (KnownDim (Product d), Elt e, RealFrac e) => RealFrac (Tensor d e)  




-- 
-- sigmoid
constant
  :: KnownDim (Product d)
  => Vector e
  -> Maybe (Tensor d e)

{-
isNaN
isInf
logicalAnd
logicalNot
logicalOr

https://github.com/hasktorch/hasktorch/blob/89988da2d00475e6215308351c8163629fc7d0e0/indef/src/Torch/Indef/Dynamic/Tensor/Math/Pointwise/Floating.hs#L250-L303

round 
  :: forall d e. Elt e
  => Elt i
  => Real e
  => Fractional e
  => Integral i 
  => T d d
  -> T d i

truncate :: Integral b => a -> b

round :: Integral b => a -> b
ceil :: Integral b => a -> b
floor :: Integral b => a -> b

class (RealFrac a, Floating a) => RealFloat a where
  floatRadix :: a -> Integer
  floatDigits :: a -> Int
  floatRange :: a -> (Int, Int)
  decodeFloat :: a -> (Integer, Int)
  encodeFloat :: Integer -> Int -> a
  exponent :: a -> Int
  significand :: a -> a
  scaleFloat :: Int -> a -> a
  isNaN :: a -> Bool
  isInfinite :: a -> Bool
  isDenormalized :: a -> Bool
  isNegativeZero :: a -> Bool
  isIEEE :: a -> Bool
  atan2 :: a -> a -> a
-}



equal
  :: Eq e
  => Tensor d e
  -> Tensor d e
  -> Tensor d Bool

notEqual
  :: Eq e
  => Tensor d e
  -> Tensor d e
  -> Tensor d Bool

less
  :: Ord e
  => Tensor d e
  -> Tensor d e
  -> Tensor d Bool

lessEqual
  :: Ord e
  => Tensor d e
  -> Tensor d e
  -> Tensor d Bool

greater
  :: Ord e
  => Tensor d e
  -> Tensor d e
  -> Tensor d Bool

greaterEqual
  :: Ord e
  => Tensor d e
  -> Tensor d e
  -> Tensor d Bool

maximum
  :: Ord e
  => Tensor d e
  -> Tensor d e
  -> Tensor d e

minimum
  :: Ord e
  => Tensor d e
  -> Tensor d e
  -> Tensor d e

{-
vector :: TensorType a => [a] -> Tensor Build a 
zeros :: forall a. (Num a, TensorType a) => Shape -> Tensor Build a


instance Floating e => Floating (T s e)
instance Fractional e => Fractional (T s e)
instance RealFrac e => RealFrac (T s e)
-}
