{-# LANGUAGE MultiParamTypeClasses, UndecidableInstances #-}

signature Data.Tensor.Internal where

-- this signature roughly correspond to tf.bitwise and tf.math in the TensorFlow Python API

import Data.Bits 
import Data.Vector.Storable (Vector)
import Numeric.Tensile.Types
import Numeric.Tensile.Index

class Elt (t :: *)
-- instance Elt TVal
-- instance Elt IVal
-- instance Elt BVal
-- 

-- | A tensor value.
data TVal :: *
instance Eq TVal
instance Num TVal
instance Floating TVal
instance Fractional TVal
-- 

-- | An index value.
data IVal :: *
instance Eq IVal
instance Num IVal
instance Ord IVal
instance Bits IVal
-- 

-- | A BValean value.
data BVal :: *
instance Eq BVal

-- | Elements are assumed to be stored in major-to-minor (i.e. row-major) order.
-- Implementations that use a different ordering must supply a conversion or risk unexpected 
-- behavior. 
data Tensor (t :: *) (d :: [Nat])

-- | A real or complex-valued tensor of shape 'd'. 
type T d = Tensor TVal d

-- | An integer or non-negative integer-valued tensor of shape 'd'. 
type I d = Tensor IVal d

-- | A boolean-valued tensor of shape 'd'. 
type B d = Tensor BVal d

-- | A variable tensor. Need ST-like interface w/ ghost type for variables.
--newtype V v (d :: [Nat]) 

instance (KnownDim (Size d), Elt t, Eq t) => Eq (Tensor t d)
instance (KnownDim (Size d), Elt t, Eq t, Bits t, Num t) => Bits (Tensor t d) 
instance (KnownDim (Size d), Elt t, Num t) => Num (Tensor t d) 
instance (KnownDim (Size d), Elt t, Fractional t) => Fractional (Tensor t d) 
instance (KnownDim (Size d), Elt t, Floating t) => Floating (Tensor t d)





{-

isNaN
isInf
logicalAnd
logicalNot
logicalOr

https://github.com/hasktorch/hasktorch/blob/89988da2d00475e6215308351c8163629fc7d0e0/indef/src/Torch/Indef/Dynamic/Tensor/Math/Pointwise/Floating.hs#L250-L303

round 
  :: forall d t. Elt t
  => Elt i
  => Real t
  => Fractional t
  => Integral i 
  => T d d
  -> T d i

truncate :: Integral b => a -> b

round :: Integral b => a -> b
ceil :: Integral b => a -> b
floor :: Integral b => a -> b

-}


eq :: T d -> T d -> B d

neq :: T d -> T d -> B d

lt :: Ord TVal => T d -> T d -> B d

lte :: Ord TVal => T d -> T d -> B d

gt :: Ord TVal => T d -> T d -> B d

gte :: Ord TVal => T d -> T d -> B d


{-

-- 
-- sigmoid


equal
  :: Elt t
  => Eq t
  => Tensor t d
  -> Tensor t d
  -> Tensor BVal d

notEqual
  :: Elt t
  => Eq t
  => Tensor t d
  -> Tensor t d
  -> Tensor BVal d

less
  :: Elt t
  => Ord t
  => Tensor t d
  -> Tensor t d
  -> Tensor BVal d

lessEqual
  :: Elt t
  => Ord t
  => Tensor t d
  -> Tensor t d
  -> Tensor BVal d

greater
  :: Elt t
  => Ord t
  => Tensor t d
  -> Tensor t d
  -> Tensor BVal d

greaterEqual
  :: Elt t
  => Ord t
  => Tensor t d
  -> Tensor t d
  -> Tensor BVal d
-}

maximum
  :: Elt t
  => Ord t
  => Tensor t d
  -> Tensor t d
  -> Tensor t d

minimum
  :: Elt t
  => Ord t
  => Tensor t d
  -> Tensor t d
  -> Tensor t d

{-
vector :: TensorType a => [a] -> Tensor Build a 
zeros :: forall a. (Num a, TensorType a) => Shape -> Tensor Build a


instance Floating t => Floating (T s e)
instance Fractional t => Fractional (T s e)
instance RealFrac t => RealFrac (T s e)
-}

reshape 
  :: forall d d' t. Elt t 
  => Reshapable d d'
  => Tensor t d -> Tensor t d'

toTensor
  :: forall d t. Elt t
  => KnownDim (Size d)
  => [t]
  -> Maybe (Tensor t d)

fromVector :: Elt t => Dims d -> Vector t -> Maybe (Tensor t d)

fill :: forall d t. Elt t => Dims d -> (Idxs d -> t) -> Tensor t d

