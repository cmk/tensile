signature Numeric.Tensile.Operations.Linear.Internal where

import Numeric.Tensile.Permutation (Perm(..))
import Numeric.Tensile.Tensor.Internal (Elt(..),Tensor(..))
import Numeric.Tensile.Types 

transpose 
  :: forall d d' e. Elt e 
  => Permutable d d'
  => Dims d -> Perm (Rank d) -> Tensor d e -> Tensor d' e

{-
matmul 
  :: forall m x y. KnownDim m
  => Dimensions x
  => Dimensions y
  => T (x +: m) -> T (m :+ y) -> T (x ++ y)



matmulR
  :: All KnownDim '[a, b, c]
  => Dimensions x
  => T (a :+ b :+ x)
  -> T (b :+ c :+ x)
  -> T (a :+ c :+ x)
matmulR = undefined

-- <#
matmulL
  :: All KnownDim '[a, b, c]
  => Dimensions x
  => T (x +: a +: b) 
  -> T (x +: b +: c)
  -> T (x +: a +: c)
matmulL = undefined

-- TODO use typesig to determine permutation
transpose 
  :: forall a x y. All KnownDim '[a, b]
  => Dimensions x
  => Dimensions y
  => T (x ++ '[a,b] ++ y) -> T (x ++ '[b,a] ++ y) 

-- TODO hopefully dont need to define shape '[] tensors as scalars? 
trace
  :: All KnownDim '[a, b, c]
  => Dimensions x
  => T (x +: a +: b) 
  -> T x
trace = undefined

-}
